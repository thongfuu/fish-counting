# -*- coding: utf-8 -*-
"""Fish Counting using Object Detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Yoyl7__kzlRJi_M8cmXJ3KIMwXS0gxw6
"""

!pip install -q numpy==1.26.4

!pip install -q roboflow

!pip install -q ultralytics

!nvidia-smi

from roboflow import Roboflow
rf = Roboflow(api_key="IckQwefe77dIWxRHVISG")
project = rf.workspace("thongfaa").project("final-mz8zy-zx0kv")
version = project.version(2)
dataset = version.download("yolov8")

from roboflow import Roboflow
rf = Roboflow(api_key="IckQwefe77dIWxRHVISG")
project = rf.workspace("thongfaa").project("final-mz8zy-zx0kv")
version = project.version(3)
dataset = version.download("yolov8-obb")

import zipfile
import os
import shutil

zip_filename = "/content/test-fish-20251101T081615Z-1-001.zip"
extract_path = "/content/test_fish"

# Create the main destination folder if it doesn't exist
os.makedirs(extract_path, exist_ok=True)

# Create subfolders for images and videos
images_path = os.path.join(extract_path, "images")
video_path = os.path.join(extract_path, "video")
os.makedirs(images_path, exist_ok=True)
os.makedirs(video_path, exist_ok=True)

# Extract the zip file
with zipfile.ZipFile(zip_filename, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

print(f"Extracted files to: {extract_path}")

# Organize files into image and video folders
for root, dirs, files in os.walk(extract_path):
    for file in files:
        file_path = os.path.join(root, file)
        # Ignore directories created by the extraction
        if os.path.isdir(file_path):
            continue

        file_extension = os.path.splitext(file)[1].lower()

        if file_extension in ('.jpg', '.jpeg'):
            shutil.move(file_path, os.path.join(images_path, file))
        elif file_extension == '.mp4':
            shutil.move(file_path, os.path.join(video_path, file))
        # Optionally, handle other file types or remove them
        # else:
        #     print(f"Ignoring file with unknown extension: {file_path}")
            # Optionally, remove ignored files
            # os.remove(file_path)

print("Files organized.")

# Display the new folder structure
print(f"\nNew folder structure in {extract_path}:")
for root, dirs, files in os.walk(extract_path):
    level = root.replace(extract_path, '').count(os.sep)
    indent = ' ' * 4 * level
    print(f"{indent}{os.path.basename(root)}/")
    subindent = ' ' * 4 * (level + 1)
    for f in files[:5]:  # Display only the first 5 files in each directory
        print(f"{subindent}{f}")

from ultralytics import YOLO

model = YOLO('yolov8s-obb.pt')

!yolo detect train data=/content/final-3/data.yaml model=yolov8s-obb.pt epochs=60 imgsz=640

!yolo detect predict model=/content/runs/obb/train/weights/best.pt source=/content/final-3/valid/images save=True max_det=1000

import glob
from IPython.display import Image, display
for image_path in glob.glob(f'/content/runs/obb/predict/*.jpg')[:10]:
  display(Image(filename=image_path, height=640))
  print('\n')

# โหลดโมเดลที่เทรนเสร็จแล้ว
model = YOLO('/content/runs/obb/train/weights/best.pt')

import cv2
import matplotlib.pyplot as plt

def process_image(image_path, model, target_class='fish'):
    # อ่านภาพ
    img = cv2.imread(image_path)
    results = model.predict(
    source=img,
    conf=0.15,     # ลด threshold ให้ตรวจเพิ่ม
    iou=0.85,      # อนุญาตกล่องทับกันมากขึ้น
    imgsz=640,     # แยกลายปลาได้ดีขึ้น
    max_det=2000,
    verbose=False
)

    detections = results[0]
    boxes = detections.boxes.xyxy.cpu().numpy()
    classes = detections.boxes.cls.cpu().numpy()
    confs = detections.boxes.conf.cpu().numpy()
    names = model.names

    fish_count = 0

    for box, cls_id, conf in zip(boxes, classes, confs):
        label = names[int(cls_id)]
        if label.lower() == target_class:
            fish_count += 1
            x1, y1, x2, y2 = map(int, box)
            cv2.rectangle(img, (x1, y1), (x2, y2), (0,255,0), 2)
            cv2.putText(img, f'{label} {conf:.2f}', (x1, y1-10),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)

    # ใส่ข้อความนับจำนวน
    cv2.putText(img, f'Fish Count: {fish_count}', (20, 40),
                cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0,0,255), 3)

    # แสดงผล
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    plt.figure(figsize=(8,6))
    plt.imshow(img_rgb)
    plt.axis('off')
    plt.show()

    return fish_count

import cv2
import matplotlib.pyplot as plt
import numpy as np

def process_image_obb(image_path, model, target_class='fish'):
    # อ่านภาพ
    img = cv2.imread(image_path)

    results = model.predict(
        source=img,
        conf=0.15,
        iou=0.85,
        imgsz=640,
        max_det=2000,
        verbose=False
    )

    detections = results[0]
    obb_boxes = detections.obb.xywhr.cpu().numpy()   # ✅ กล่องแบบ OBB
    classes = detections.obb.cls.cpu().numpy()
    confs = detections.obb.conf.cpu().numpy()
    names = model.names

    fish_count = 0

    for box, cls_id, conf in zip(obb_boxes, classes, confs):
        label = names[int(cls_id)]

        if label.lower() == target_class:
            fish_count += 1

            # แปลง OBB (x,y,w,h,r) → polygon 4 จุด
            x, y, w, h, r = box
            r = np.deg2rad(r)   # หมุนองศา → radian

            # คำนวณ 4 จุดของกรอบหมุน
            cos_r = np.cos(r)
            sin_r = np.sin(r)
            dx = w / 2
            dy = h / 2

            corners = np.array([
                [x - dx*cos_r + dy*sin_r, y - dx*sin_r - dy*cos_r],
                [x + dx*cos_r + dy*sin_r, y + dx*sin_r - dy*cos_r],
                [x + dx*cos_r - dy*sin_r, y + dx*sin_r + dy*cos_r],
                [x - dx*cos_r - dy*sin_r, y - dx*sin_r + dy*cos_r]
            ], dtype=int)

            # วาด polygon
            cv2.polylines(img, [corners], True, (0,255,0), 2)

            # ใส่ข้อความ confidence
            #cv2.putText(img, f'{label} {conf:.2f}', (int(x), int(y)),
                        #cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)

    # แสดงจำนวนปลา
    cv2.putText(img, f'Fish Count: {fish_count}', (20,40),
                cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0,0,255), 3)

    # แสดงภาพ
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    plt.figure(figsize=(8,6))
    plt.imshow(img_rgb)
    plt.axis('off')
    plt.show()

    return fish_count

count = process_image('/content/test_fish/images/Fish-7.jpg', model)
print("Fish detected:", count)

count = process_image_obb("/content/test_fish/images/Fish-7.jpg", model)
print("Fish detected:", count)

folder_path = '/content/test_fish/images'

for filename in os.listdir(folder_path):
    if filename.lower().endswith(('.jpg', '.jpeg', '.png')):
        img_path = os.path.join(folder_path, filename)
        print(f"Processing: {filename}")
        count = process_image_obb(img_path, model)
        print(f"{filename} -> Fish detected: {count}")
        print("-" * 40)

def process_video(video_path, model, output_path='output_fish.mp4', target_class='fish'):
    cap = cv2.VideoCapture(video_path)
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    fps = int(cap.get(cv2.CAP_PROP_FPS))
    w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

    out = cv2.VideoWriter(output_path, fourcc, fps, (w, h))

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        results = model.predict(
          source=frame,
          conf=0.15,
          iou=0.85,
          imgsz=640,
          max_det=1000,
          verbose=False
        )
        detections = results[0]
        boxes = detections.boxes.xyxy.cpu().numpy()
        classes = detections.boxes.cls.cpu().numpy()
        confs = detections.boxes.conf.cpu().numpy()
        names = model.names

        fish_count = 0

        for box, cls_id, conf in zip(boxes, classes, confs):
            label = names[int(cls_id)]
            if label.lower() == target_class:
                fish_count += 1
                x1, y1, x2, y2 = map(int, box)
                cv2.rectangle(frame, (x1, y1), (x2, y2), (0,255,0), 2)
                cv2.putText(frame, f'{label} {conf:.2f}', (x1, y1-10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)

        cv2.putText(frame, f'Fish Count: {fish_count}', (20, 40),
                    cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0,0,255), 3)

        out.write(frame)

    cap.release()
    out.release()
    print(f"✅ Video saved to: {output_path}")

process_video('/content/test_fish/video/vdo-1.mp4', model, output_path='fish_detected.mp4')

video_folder = '/content/test_fish/video'
output_folder = '/content/output'

# สร้างโฟลเดอร์ output ถ้ายังไม่มี
os.makedirs(output_folder, exist_ok=True)

for filename in os.listdir(video_folder):
    # รองรับไฟล์วิดีโอทั่ว ๆ ไป
    if filename.lower().endswith(('.mp4', '.avi', '.mov', '.mkv')):
        input_path = os.path.join(video_folder, filename)
        output_path = os.path.join(output_folder, f"detected_{filename}")

        print(f"Processing video: {filename}")
        process_video(input_path, model, output_path=output_path)
        print(f"✔ Finished -> {output_path}")
        print("-" * 50)